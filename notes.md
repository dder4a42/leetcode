# Notes

## Find K Pairs with Smallest Sums

```
给定两个以 非递减顺序排列 的整数数组 nums1 和 nums2 , 以及一个整数 k 。

定义一对值 (u,v)，其中第一个元素来自 nums1，第二个元素来自 nums2 。

请找到和最小的 k 个数对 (u1,v1),  (u2,v2)  ...  (uk,vk) 。
```

min-heap 的作用是维护一个候选区，持续取出最小元素。设两数组的长度为 `n` 和 `m`，则最 native 的做法是遍历 `[a[i], b[j]]` 并记录 `sum([x, y])` 最小的 k 个元素，时间复杂度为 `O(nm*log k)`，在大数组输入时容易超时。

注意到输入的 `a[], b[]` 均为升序数组，则在 `n*m` 的结果矩阵 `A[i][j]=a[i]+b[j]` 中，满足

$$
A[i][j] \le A[i+1][j] \\
A[i][j] \le A[i][j+1]
$$

因而最小的元素为 `A[0][0]`，下一个比它大的元素在 `A[1][0]` 和 `A[0][1]` 之中。若已知 `A[i][j]` 为第 t 小的元素，则只需在所有比其大的元素中取出最小的那一个。特别地，可以用大小为 h 的 min-heap 维护剩余元素的一个子集，且这些元素的确是剩下元素中最小的 h 个——只需不停地取出堆顶元素，并将其后继邻居入堆。
这里的一个问题是，`A[i][j]` 可以被 `A[i-1][j]` 或 `A[i][j-1]` 重复入堆。除了哈希去重外，可以约定每个元素仅有一种入堆来源，如约定仅由左侧元素入堆；此时，需要将不存在左侧元素的 `A[i][0]` 在初始化 min-heap 时手动入堆。

> 完全是一个合并多重有序链表问题

> 小优化：最小的 k 个元素必然满足 $i\le k\ \wedge\ j \le k$，为 min-heap 初始化时可取 `min(k, len(nums1))` 的行首

取出最小的 k 个元素需要出堆 k 次，并入堆 k 次，每次入堆耗时 log k，则时间复杂度为 `O(k log k)`

##  The next greater

```
给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。

求在该柱状图中，能够勾勒出来的矩形的最大面积。
```

如何在崎岖柱状图的内部撑开一个尽可能大的矩形？显然，非常容易被限高卡住矩形上限，而且不好直接比较那些撑到极限的矩形，只能遍历它们。那么，这里的问题变成了，如何获取这些候选的极大矩形？
既然限高是关键，可以对任意一根柱子 `heights[i]` ，向两侧扩展该矩形，直到撞到 `heights[i-li]` 和 `heights[i+ri]`，即两侧的下一个比自己矮的柱子。

单调栈恰好可以为每个元素找到下一个比自己小的元素，准确地说，是在单调栈被破坏时得知栈中元素的下一个比自己小的元素的出现。

1. 初始化栈，将 0-th 元素入栈
2. 遍历数组，将每个元素入栈，并维护单调增的序列。入栈时，比较 i-th 元素和栈顶元素，若破坏单调性，则不断 pop，直至新元素入栈后满足单调性。
    + 此时，被出栈元素的找到了 next smaller 元素，确定矩形的右边界
    + 出栈结束时，栈顶元素为 i-th 元素的 next smaller in left


## Minimum Operations to Make the Array Increasing

```
给你一个整数数组 target 。一开始，你有一个数组 A ，它的所有元素均为 1 ，你可以执行以下操作：

    令 x 为你数组里所有元素的和
    选择满足 0 <= i < target.size 的任意下标 i ，并让 A 数组里下标为 i 处的值为 x 。
    你可以重复该过程任意次

如果能从 A 开始构造出目标数组 target ，请你返回 True ，否则返回 False 。

提示：

    N == target.length
    1 <= target.length <= 5 * 10^4
    1 <= target[i] <= 10^9
```

数组非负，则 x 递增。由于 `sum(target)` 大于数组中任意元素，则更新后 `x:=max(target)`，可逆向模拟该数组的构造过程，检查是否能还原为 `[1]*n`.

+ 使用 max-heap 维护数组最大值
+ 使用 partial-sum 变量维护剩余元素和：`new_p_sum = old_p_sum - old_max_element + new_max_element`
+ 检查退出条件

检查是否全为一有不同方法，如所有元素非负且和为一，或所有元素非负且最大值为一。

+ 非负性：新元素为`max_ele - p_sum`，检查 `max_ele > p_sum` 且 `p_sum > 0`
+ 最大值：默认的 heapq 为 min-heap，则将 `(-x, idx)` 入堆，按字典序排列

若某元素特别大，则可以将多次减法优化为 mod 运算，即将 `new_val = max_ele - p_sum` 变为 `new_val = max_ele % p_sum`。值得注意的是 mod 为 0 的情况：

+ 若 `p_sum` 为 1, 则返回 True
+ 若否，则说明会减到 0,返回 False

## string

+ `s+s` 包含了字符串 `s` 通过旋转得到的所有可能字符串
+ KMP ?

##  Hash

### two sum

```
给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。

你可以假设每种输入只会对应一个答案，并且你不能使用两次相同的元素。

你可以按任意顺序返回答案。

提示：

    2 <= nums.length <= 104
    -109 <= nums[i] <= 109
    -109 <= target <= 109
    只会存在一个有效答案

进阶：你可以想出一个时间复杂度小于 O(n2) 的算法吗？
```

BF 算法是遍历 $\binom{n}{2}$ 个数对，检查是否和为 target；对于存在性问题，可以转化为对任意给定 $x\in nums$，检查 $target-x$ 是否在数组中，而该检查能够在第一次遍历到 $y\in nums$ 时进行，也就不需要遍历第二遍。

### firstMissingPositive

```
给你一个未排序的整数数组 nums ，请你找出其中没有出现的最小的正整数。
请你实现时间复杂度为 O(n) 并且只使用常数级别额外空间的解决方案。 

提示：
    1 <= nums.length <= 10^5
    -2^31 <= nums[i] <= 2^31 - 1
```

最暴力的方法是，从小到大枚举正整数，对每个正整数，遍历数组检查其是否出现，寻找第一个未出现的正整数。边界情况是遍历 N 次均能在数组中找到被枚举正整数，则答案为 N+1,因而时间复杂度为 O(N^2)

若能将数组存入哈希表，则查询 i 是否出现的时间为 O(1)，那么时间复杂度将为 O(N)，仅需遍历一边数组存哈希，再遍历一遍正整数 1~N 查询是否出现。

由于不能使用额外空间，就只能用原地算法，修改输入。首先，由于答案出现在 [1,N+1]，可以将超出两侧的数舍弃。接着，将 1~N 间的数 `nums[i]` 放到对应下标位置 `nums[i]` ，顶掉该位置的元素 `nums[nums[i]]`. 此时，需要在原地继续将被顶掉的元素放到对应位置，直至遇到重复元素或超出范围。

### minSubarray

```
给你一个正整数数组 nums，请你移除 最短 子数组（可以为 空），使得剩余元素的 和 能被 p 整除。 不允许 将整个数组都移除。

请你返回你需要移除的最短子数组的长度，如果无法满足题目要求，返回 -1 。

子数组 定义为原数组中连续的一组元素。

提示：
    1 <= nums.length <= 105
    1 <= nums[i] <= 109
    1 <= p <= 109
```

数据量较大，考虑 $O(n)$ 算法。输出结果仅要求子数组长度，不要求具体的子数组，说明很可能存在取巧方法。为实现一次遍历，而不是动态规划一样暴力搜索 `sum(i,j)` ，可以将连续子数组的和 $\sum_{t=i}^j arr[t]$ 写为前缀和之差 `p_sum[j+1]-p_sum[i]`，其中前缀和数组长度为 $n+1$，且 `p_sum[0]=0`。

现考察整除的性质，若移除子数组 $nums[l:r)$ 后，剩余和能被 $p$ 整除，则：

$$
\text{p-sum}[n] \equiv \left(\text{p-sum}[r] - \text{p-sum}[l]\right) \pmod p
$$

记 $R = ps[n] \bmod p$。问题转化为寻找满足 $0 \le l < r \le n$ 的索引对 $(l,r)$，使得：

$$
(\text{p-sum}[r] - \text{p-sum}[l]) \bmod p = R
$$

利用模运算性质，将其分配到减法中，并写为同余形式

$$
\begin{aligned}
(\text{p-sum}[r] - \text{p-sum}[l]) \bmod p &= R \\
(\text{p-sum}[r] \bmod p - \text{p-sum}[l] \bmod p) \bmod p &= R \\
\text{p-sum}[r] \bmod p - \text{p-sum}[l] \bmod p &\equiv R \pmod p
\end{aligned}
$$

定义前缀模数组 $\text{p-mod}[i] := \text{p-sum}[i] \bmod p$，对同余式移项得到

$$
pm[l] \equiv pm[r] - R \pmod p
$$

即对于每个下标`j`，检查对所有下标`i<j`，是否存在`p_mod[i] == (p_mod[j]-r) % p`，使用哈希表实现 O(1) 查询。

