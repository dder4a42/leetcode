# Notes

## Find K Pairs with Smallest Sums

```
给定两个以 非递减顺序排列 的整数数组 nums1 和 nums2 , 以及一个整数 k 。

定义一对值 (u,v)，其中第一个元素来自 nums1，第二个元素来自 nums2 。

请找到和最小的 k 个数对 (u1,v1),  (u2,v2)  ...  (uk,vk) 。
```

min-heap 的作用是维护一个候选区，持续取出最小元素。设两数组的长度为 `n` 和 `m`，则最 native 的做法是遍历 `[a[i], b[j]]` 并记录 `sum([x, y])` 最小的 k 个元素，时间复杂度为 `O(nm*log k)`，在大数组输入时容易超时。

注意到输入的 `a[], b[]` 均为升序数组，则在 `n*m` 的结果矩阵 `A[i][j]=a[i]+b[j]` 中，满足

$$
A[i][j] \le A[i+1][j] \\
A[i][j] \le A[i][j+1]
$$

因而最小的元素为 `A[0][0]`，下一个比它大的元素在 `A[1][0]` 和 `A[0][1]` 之中。若已知 `A[i][j]` 为第 t 小的元素，则只需在所有比其大的元素中取出最小的那一个。特别地，可以用大小为 h 的 min-heap 维护剩余元素的一个子集，且这些元素的确是剩下元素中最小的 h 个——只需不停地取出堆顶元素，并将其后继邻居入堆。
这里的一个问题是，`A[i][j]` 可以被 `A[i-1][j]` 或 `A[i][j-1]` 重复入堆。除了哈希去重外，可以约定每个元素仅有一种入堆来源，如约定仅由左侧元素入堆；此时，需要将不存在左侧元素的 `A[i][0]` 在初始化 min-heap 时手动入堆。

> 完全是一个合并多重有序链表问题

> 小优化：最小的 k 个元素必然满足 $i\le k\ \wedge\ j \le k$，为 min-heap 初始化时可取 `min(k, len(nums1))` 的行首

取出最小的 k 个元素需要出堆 k 次，并入堆 k 次，每次入堆耗时 log k，则时间复杂度为 `O(k log k)`

##  The next greater

```
给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。

求在该柱状图中，能够勾勒出来的矩形的最大面积。
```

如何在崎岖柱状图的内部撑开一个尽可能大的矩形？显然，非常容易被限高卡住矩形上限，而且不好直接比较那些撑到极限的矩形，只能遍历它们。那么，这里的问题变成了，如何获取这些候选的极大矩形？
既然限高是关键，可以对任意一根柱子 `heights[i]` ，向两侧扩展该矩形，直到撞到 `heights[i-li]` 和 `heights[i+ri]`，即两侧的下一个比自己矮的柱子。

单调栈恰好可以为每个元素找到下一个比自己小的元素，准确地说，是在单调栈被破坏时得知栈中元素的下一个比自己小的元素的出现。

1. 初始化栈，将 0-th 元素入栈
2. 遍历数组，将每个元素入栈，并维护单调增的序列。入栈时，比较 i-th 元素和栈顶元素，若破坏单调性，则不断 pop，直至新元素入栈后满足单调性。
    + 此时，被出栈元素的找到了 next smaller 元素，确定矩形的右边界
    + 出栈结束时，栈顶元素为 i-th 元素的 next smaller in left


## Minimum Operations to Make the Array Increasing

```
给你一个整数数组 target 。一开始，你有一个数组 A ，它的所有元素均为 1 ，你可以执行以下操作：

    令 x 为你数组里所有元素的和
    选择满足 0 <= i < target.size 的任意下标 i ，并让 A 数组里下标为 i 处的值为 x 。
    你可以重复该过程任意次

如果能从 A 开始构造出目标数组 target ，请你返回 True ，否则返回 False 。
```

